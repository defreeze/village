{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nimport { EventEmitter, CodedError, UnavailabilityError } from '@unimodules/core';\nimport NotificationsHandlerModule from \"./NotificationsHandlerModule\";\nexport var NotificationTimeoutError = function (_CodedError) {\n  function NotificationTimeoutError(notificationId, notification) {\n    var _this;\n    _classCallCheck(this, NotificationTimeoutError);\n    _this = _callSuper(this, NotificationTimeoutError, ['ERR_NOTIFICATION_TIMEOUT', \"Notification handling timed out for ID \" + notificationId + \".\"]);\n    _this.info = {\n      id: notificationId,\n      notification: notification\n    };\n    return _this;\n  }\n  _inherits(NotificationTimeoutError, _CodedError);\n  return _createClass(NotificationTimeoutError);\n}(CodedError);\nvar notificationEmitter = new EventEmitter(NotificationsHandlerModule);\nvar handleNotificationEventName = 'onHandleNotification';\nvar handleNotificationTimeoutEventName = 'onHandleNotificationTimeout';\nvar handleSubscription = null;\nvar handleTimeoutSubscription = null;\nexport function setNotificationHandler(handler) {\n  if (handleSubscription) {\n    handleSubscription.remove();\n    handleSubscription = null;\n  }\n  if (handleTimeoutSubscription) {\n    handleTimeoutSubscription.remove();\n    handleTimeoutSubscription = null;\n  }\n  if (handler) {\n    handleSubscription = notificationEmitter.addListener(handleNotificationEventName, function _callee(_ref) {\n      var id, notification, behavior;\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            id = _ref.id, notification = _ref.notification;\n            if (NotificationsHandlerModule.handleNotificationAsync) {\n              _context.next = 4;\n              break;\n            }\n            handler.handleError == null ? void 0 : handler.handleError(id, new UnavailabilityError('Notifications', 'handleNotificationAsync'));\n            return _context.abrupt(\"return\");\n          case 4:\n            _context.prev = 4;\n            _context.next = 7;\n            return _regeneratorRuntime.awrap(handler.handleNotification(notification));\n          case 7:\n            behavior = _context.sent;\n            _context.next = 10;\n            return _regeneratorRuntime.awrap(NotificationsHandlerModule.handleNotificationAsync(id, behavior));\n          case 10:\n            handler.handleSuccess == null ? void 0 : handler.handleSuccess(id);\n            _context.next = 16;\n            break;\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](4);\n            handler.handleError == null ? void 0 : handler.handleError(id, _context.t0);\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }, null, null, [[4, 13]], Promise);\n    });\n    handleTimeoutSubscription = notificationEmitter.addListener(handleNotificationTimeoutEventName, function (_ref2) {\n      var id = _ref2.id,\n        notification = _ref2.notification;\n      return handler.handleError == null ? void 0 : handler.handleError(id, new NotificationTimeoutError(id, notification));\n    });\n  }\n}","map":{"version":3,"names":["EventEmitter","CodedError","UnavailabilityError","NotificationsHandlerModule","NotificationTimeoutError","_CodedError","notificationId","notification","_this","_classCallCheck","_callSuper","info","id","_inherits","_createClass","notificationEmitter","handleNotificationEventName","handleNotificationTimeoutEventName","handleSubscription","handleTimeoutSubscription","setNotificationHandler","handler","remove","addListener","_callee","_ref","behavior","_regeneratorRuntime","async","_callee$","_context","prev","next","handleNotificationAsync","handleError","abrupt","awrap","handleNotification","sent","handleSuccess","t0","stop","Promise","_ref2"],"sources":["C:\\Users\\alexd\\Documents\\InstagramClone\\frontend\\node_modules\\expo-notifications\\src\\NotificationsHandler.ts"],"sourcesContent":["import { EventEmitter, Subscription, CodedError, UnavailabilityError } from '@unimodules/core';\n\nimport { Notification, NotificationBehavior } from './Notifications.types';\nimport NotificationsHandlerModule from './NotificationsHandlerModule';\n\nexport class NotificationTimeoutError extends CodedError {\n  info: { notification: Notification; id: string };\n  constructor(notificationId: string, notification: Notification) {\n    super('ERR_NOTIFICATION_TIMEOUT', `Notification handling timed out for ID ${notificationId}.`);\n    this.info = { id: notificationId, notification };\n  }\n}\n\nexport type NotificationHandlingError = NotificationTimeoutError | Error;\n\nexport interface NotificationHandler {\n  handleNotification: (notification: Notification) => Promise<NotificationBehavior>;\n  handleSuccess?: (notificationId: string) => void;\n  handleError?: (notificationId: string, error: NotificationHandlingError) => void;\n}\n\ntype HandleNotificationEvent = {\n  id: string;\n  notification: Notification;\n};\n\ntype HandleNotificationTimeoutEvent = HandleNotificationEvent;\n\n// Web uses SyntheticEventEmitter\nconst notificationEmitter = new EventEmitter(NotificationsHandlerModule);\n\nconst handleNotificationEventName = 'onHandleNotification';\nconst handleNotificationTimeoutEventName = 'onHandleNotificationTimeout';\n\nlet handleSubscription: Subscription | null = null;\nlet handleTimeoutSubscription: Subscription | null = null;\n\nexport function setNotificationHandler(handler: NotificationHandler | null): void {\n  if (handleSubscription) {\n    handleSubscription.remove();\n    handleSubscription = null;\n  }\n  if (handleTimeoutSubscription) {\n    handleTimeoutSubscription.remove();\n    handleTimeoutSubscription = null;\n  }\n\n  if (handler) {\n    handleSubscription = notificationEmitter.addListener<HandleNotificationEvent>(\n      handleNotificationEventName,\n      async ({ id, notification }) => {\n        if (!NotificationsHandlerModule.handleNotificationAsync) {\n          handler.handleError?.(\n            id,\n            new UnavailabilityError('Notifications', 'handleNotificationAsync')\n          );\n          return;\n        }\n\n        try {\n          const behavior = await handler.handleNotification(notification);\n          await NotificationsHandlerModule.handleNotificationAsync(id, behavior);\n          handler.handleSuccess?.(id);\n        } catch (error) {\n          handler.handleError?.(id, error);\n        }\n      }\n    );\n\n    handleTimeoutSubscription = notificationEmitter.addListener<HandleNotificationTimeoutEvent>(\n      handleNotificationTimeoutEventName,\n      ({ id, notification }) =>\n        handler.handleError?.(id, new NotificationTimeoutError(id, notification))\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}