{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { EventEmitter, Platform } from '@unimodules/core';\nimport { PermissionStatus } from 'expo-modules-core';\nimport { _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS } from \"../AV\";\nimport ExponentAV from \"../ExponentAV\";\nimport { isAudioEnabled, throwIfAudioIsDisabled } from \"./AudioAvailability\";\nimport { Sound } from \"./Sound\";\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\nexport var RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport var RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport var RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport var RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport var RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\nexport var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\nexport var RECORDING_OPTIONS_PRESET_HIGH_QUALITY = {\n  isMeteringEnabled: true,\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false\n  }\n};\nexport var RECORDING_OPTIONS_PRESET_LOW_QUALITY = {\n  isMeteringEnabled: true,\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false\n  }\n};\nexport { PermissionStatus };\nvar _recorderExists = false;\nvar eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\nexport function getPermissionsAsync() {\n  return _regeneratorRuntime.async(function getPermissionsAsync$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        return _context.abrupt(\"return\", ExponentAV.getPermissionsAsync());\n      case 1:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, null, Promise);\n}\nexport function requestPermissionsAsync() {\n  return _regeneratorRuntime.async(function requestPermissionsAsync$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        return _context2.abrupt(\"return\", ExponentAV.requestPermissionsAsync());\n      case 1:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, null, null, null, Promise);\n}\nexport var Recording = function () {\n  function Recording() {\n    var _this = this;\n    _classCallCheck(this, Recording);\n    this._subscription = null;\n    this._canRecord = false;\n    this._isDoneRecording = false;\n    this._finalDurationMillis = 0;\n    this._uri = null;\n    this._onRecordingStatusUpdate = null;\n    this._progressUpdateTimeoutVariable = null;\n    this._progressUpdateIntervalMillis = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n    this._options = null;\n    this._cleanupForUnloadedRecorder = function _callee(finalStatus) {\n      var _finalStatus$duration;\n      return _regeneratorRuntime.async(function _callee$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _this._canRecord = false;\n            _this._isDoneRecording = true;\n            _this._finalDurationMillis = (_finalStatus$duration = finalStatus == null ? void 0 : finalStatus.durationMillis) != null ? _finalStatus$duration : 0;\n            _recorderExists = false;\n            if (_this._subscription) {\n              _this._subscription.remove();\n              _this._subscription = null;\n            }\n            _this._disablePolling();\n            _context3.next = 8;\n            return _regeneratorRuntime.awrap(_this.getStatusAsync());\n          case 8:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, null, null, null, Promise);\n    };\n    this._pollingLoop = function _callee2() {\n      return _regeneratorRuntime.async(function _callee2$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!(isAudioEnabled() && _this._canRecord && _this._onRecordingStatusUpdate != null)) {\n              _context4.next = 10;\n              break;\n            }\n            _this._progressUpdateTimeoutVariable = setTimeout(_this._pollingLoop, _this._progressUpdateIntervalMillis);\n            _context4.prev = 2;\n            _context4.next = 5;\n            return _regeneratorRuntime.awrap(_this.getStatusAsync());\n          case 5:\n            _context4.next = 10;\n            break;\n          case 7:\n            _context4.prev = 7;\n            _context4.t0 = _context4[\"catch\"](2);\n            _this._disablePolling();\n          case 10:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, null, null, [[2, 7]], Promise);\n    };\n    this.getStatusAsync = function _callee3() {\n      var status;\n      return _regeneratorRuntime.async(function _callee3$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!_this._canRecord) {\n              _context5.next = 2;\n              break;\n            }\n            return _context5.abrupt(\"return\", _this._performOperationAndHandleStatusAsync(function () {\n              return ExponentAV.getAudioRecordingStatus();\n            }));\n          case 2:\n            status = {\n              canRecord: false,\n              isRecording: false,\n              isDoneRecording: _this._isDoneRecording,\n              durationMillis: _this._finalDurationMillis\n            };\n            _this._callOnRecordingStatusUpdateForNewStatus(status);\n            return _context5.abrupt(\"return\", status);\n          case 5:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, null, null, null, Promise);\n    };\n  }\n  return _createClass(Recording, [{\n    key: \"_disablePolling\",\n    value: function _disablePolling() {\n      if (this._progressUpdateTimeoutVariable != null) {\n        clearTimeout(this._progressUpdateTimeoutVariable);\n        this._progressUpdateTimeoutVariable = null;\n      }\n    }\n  }, {\n    key: \"_enablePollingIfNecessaryAndPossible\",\n    value: function _enablePollingIfNecessaryAndPossible() {\n      if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n        this._disablePolling();\n        this._pollingLoop();\n      }\n    }\n  }, {\n    key: \"_callOnRecordingStatusUpdateForNewStatus\",\n    value: function _callOnRecordingStatusUpdateForNewStatus(status) {\n      if (this._onRecordingStatusUpdate != null) {\n        this._onRecordingStatusUpdate(status);\n      }\n    }\n  }, {\n    key: \"_performOperationAndHandleStatusAsync\",\n    value: function _performOperationAndHandleStatusAsync(operation) {\n      var status;\n      return _regeneratorRuntime.async(function _performOperationAndHandleStatusAsync$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            throwIfAudioIsDisabled();\n            if (!this._canRecord) {\n              _context6.next = 9;\n              break;\n            }\n            _context6.next = 4;\n            return _regeneratorRuntime.awrap(operation());\n          case 4:\n            status = _context6.sent;\n            this._callOnRecordingStatusUpdateForNewStatus(status);\n            return _context6.abrupt(\"return\", status);\n          case 9:\n            throw new Error('Cannot complete operation because this recorder is not ready to record.');\n          case 10:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setOnRecordingStatusUpdate\",\n    value: function setOnRecordingStatusUpdate(onRecordingStatusUpdate) {\n      this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n      if (onRecordingStatusUpdate == null) {\n        this._disablePolling();\n      } else {\n        this._enablePollingIfNecessaryAndPossible();\n      }\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"setProgressUpdateInterval\",\n    value: function setProgressUpdateInterval(progressUpdateIntervalMillis) {\n      this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"prepareToRecordAsync\",\n    value: function prepareToRecordAsync() {\n      var options,\n        extensionRegex,\n        _await$ExponentAV$pre,\n        uri,\n        status,\n        currentStatus,\n        _args7 = arguments;\n      return _regeneratorRuntime.async(function prepareToRecordAsync$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            options = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : RECORDING_OPTIONS_PRESET_LOW_QUALITY;\n            throwIfAudioIsDisabled();\n            if (!_recorderExists) {\n              _context7.next = 4;\n              break;\n            }\n            throw new Error('Only one Recording object can be prepared at a given time.');\n          case 4:\n            if (!this._isDoneRecording) {\n              _context7.next = 6;\n              break;\n            }\n            throw new Error('This Recording object is done recording; you must make a new one.');\n          case 6:\n            if (!(!options || !options.android || !options.ios)) {\n              _context7.next = 8;\n              break;\n            }\n            throw new Error('You must provide recording options for android and ios in order to prepare to record.');\n          case 8:\n            extensionRegex = /^\\.\\w+$/;\n            if (!(!options.android.extension || !options.ios.extension || !extensionRegex.test(options.android.extension) || !extensionRegex.test(options.ios.extension))) {\n              _context7.next = 11;\n              break;\n            }\n            throw new Error(\"Your file extensions must match \" + extensionRegex.toString() + \".\");\n          case 11:\n            if (this._canRecord) {\n              _context7.next = 28;\n              break;\n            }\n            if (eventEmitter) {\n              this._subscription = eventEmitter.addListener('Expo.Recording.recorderUnloaded', this._cleanupForUnloadedRecorder);\n            }\n            _context7.next = 15;\n            return _regeneratorRuntime.awrap(ExponentAV.prepareAudioRecorder(options));\n          case 15:\n            _await$ExponentAV$pre = _context7.sent;\n            uri = _await$ExponentAV$pre.uri;\n            status = _await$ExponentAV$pre.status;\n            _recorderExists = true;\n            this._uri = uri;\n            this._options = options;\n            this._canRecord = true;\n            currentStatus = _objectSpread(_objectSpread({}, status), {}, {\n              canRecord: true\n            });\n            this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n            this._enablePollingIfNecessaryAndPossible();\n            return _context7.abrupt(\"return\", currentStatus);\n          case 28:\n            throw new Error('This Recording object is already prepared to record.');\n          case 29:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"startAsync\",\n    value: function startAsync() {\n      return _regeneratorRuntime.async(function startAsync$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", this._performOperationAndHandleStatusAsync(function () {\n              return ExponentAV.startAudioRecording();\n            }));\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"pauseAsync\",\n    value: function pauseAsync() {\n      return _regeneratorRuntime.async(function pauseAsync$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            return _context9.abrupt(\"return\", this._performOperationAndHandleStatusAsync(function () {\n              return ExponentAV.pauseAudioRecording();\n            }));\n          case 1:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"stopAndUnloadAsync\",\n    value: function stopAndUnloadAsync() {\n      var stopResult, stopError, status;\n      return _regeneratorRuntime.async(function stopAndUnloadAsync$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            if (this._canRecord) {\n              _context10.next = 6;\n              break;\n            }\n            if (!this._isDoneRecording) {\n              _context10.next = 5;\n              break;\n            }\n            throw new Error('Cannot unload a Recording that has already been unloaded.');\n          case 5:\n            throw new Error('Cannot unload a Recording that has not been prepared.');\n          case 6:\n            _context10.prev = 6;\n            _context10.next = 9;\n            return _regeneratorRuntime.awrap(ExponentAV.stopAudioRecording());\n          case 9:\n            stopResult = _context10.sent;\n            _context10.next = 15;\n            break;\n          case 12:\n            _context10.prev = 12;\n            _context10.t0 = _context10[\"catch\"](6);\n            stopError = _context10.t0;\n          case 15:\n            _context10.next = 17;\n            return _regeneratorRuntime.awrap(ExponentAV.unloadAudioRecorder());\n          case 17:\n            _context10.next = 19;\n            return _regeneratorRuntime.awrap(this._cleanupForUnloadedRecorder(stopResult));\n          case 19:\n            status = _context10.sent;\n            return _context10.abrupt(\"return\", stopError ? Promise.reject(stopError) : status);\n          case 21:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, null, this, [[6, 12]], Promise);\n    }\n  }, {\n    key: \"getURI\",\n    value: function getURI() {\n      return this._uri;\n    }\n  }, {\n    key: \"createNewLoadedSound\",\n    value: function createNewLoadedSound() {\n      var initialStatus,\n        onPlaybackStatusUpdate,\n        _args11 = arguments;\n      return _regeneratorRuntime.async(function createNewLoadedSound$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            initialStatus = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};\n            onPlaybackStatusUpdate = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : null;\n            console.warn(\"createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name\");\n            return _context11.abrupt(\"return\", this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate));\n          case 4:\n          case \"end\":\n            return _context11.stop();\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"createNewLoadedSoundAsync\",\n    value: function createNewLoadedSoundAsync() {\n      var initialStatus,\n        onPlaybackStatusUpdate,\n        _args12 = arguments;\n      return _regeneratorRuntime.async(function createNewLoadedSoundAsync$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            initialStatus = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {};\n            onPlaybackStatusUpdate = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : null;\n            if (!(this._uri == null || !this._isDoneRecording)) {\n              _context12.next = 4;\n              break;\n            }\n            throw new Error('Cannot create sound when the Recording has not finished!');\n          case 4:\n            return _context12.abrupt(\"return\", Sound.createAsync({\n              uri: this._uri\n            }, initialStatus, onPlaybackStatusUpdate, false));\n          case 5:\n          case \"end\":\n            return _context12.stop();\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n}();\nRecording.createAsync = function _callee4() {\n  var options,\n    onRecordingStatusUpdate,\n    progressUpdateIntervalMillis,\n    recording,\n    status,\n    _args13 = arguments;\n  return _regeneratorRuntime.async(function _callee4$(_context13) {\n    while (1) switch (_context13.prev = _context13.next) {\n      case 0:\n        options = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : RECORDING_OPTIONS_PRESET_LOW_QUALITY;\n        onRecordingStatusUpdate = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : null;\n        progressUpdateIntervalMillis = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : null;\n        recording = new Recording();\n        if (progressUpdateIntervalMillis) {\n          recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n        }\n        recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n        _context13.next = 8;\n        return _regeneratorRuntime.awrap(recording.prepareToRecordAsync(_objectSpread(_objectSpread({}, options), {}, {\n          keepAudioActiveHint: true\n        })));\n      case 8:\n        _context13.prev = 8;\n        _context13.next = 11;\n        return _regeneratorRuntime.awrap(recording.startAsync());\n      case 11:\n        status = _context13.sent;\n        return _context13.abrupt(\"return\", {\n          recording: recording,\n          status: status\n        });\n      case 15:\n        _context13.prev = 15;\n        _context13.t0 = _context13[\"catch\"](8);\n        recording.stopAndUnloadAsync();\n        throw _context13.t0;\n      case 19:\n      case \"end\":\n        return _context13.stop();\n    }\n  }, null, null, [[8, 15]], Promise);\n};","map":{"version":3,"names":["EventEmitter","Platform","PermissionStatus","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","ExponentAV","isAudioEnabled","throwIfAudioIsDisabled","Sound","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD","RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3","RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN","RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW","RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM","RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH","RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE","RECORDING_OPTIONS_PRESET_HIGH_QUALITY","isMeteringEnabled","android","extension","outputFormat","audioEncoder","sampleRate","numberOfChannels","bitRate","ios","audioQuality","linearPCMBitDepth","linearPCMIsBigEndian","linearPCMIsFloat","RECORDING_OPTIONS_PRESET_LOW_QUALITY","_recorderExists","eventEmitter","OS","getPermissionsAsync","_regeneratorRuntime","async","getPermissionsAsync$","_context","prev","next","abrupt","stop","Promise","requestPermissionsAsync","requestPermissionsAsync$","_context2","Recording","_this","_classCallCheck","_subscription","_canRecord","_isDoneRecording","_finalDurationMillis","_uri","_onRecordingStatusUpdate","_progressUpdateTimeoutVariable","_progressUpdateIntervalMillis","_options","_cleanupForUnloadedRecorder","_callee","finalStatus","_finalStatus$duration","_callee$","_context3","durationMillis","remove","_disablePolling","awrap","getStatusAsync","sent","_pollingLoop","_callee2","_callee2$","_context4","setTimeout","t0","_callee3","status","_callee3$","_context5","_performOperationAndHandleStatusAsync","getAudioRecordingStatus","canRecord","isRecording","isDoneRecording","_callOnRecordingStatusUpdateForNewStatus","_createClass","key","value","clearTimeout","_enablePollingIfNecessaryAndPossible","operation","_performOperationAndHandleStatusAsync$","_context6","Error","setOnRecordingStatusUpdate","onRecordingStatusUpdate","setProgressUpdateInterval","progressUpdateIntervalMillis","prepareToRecordAsync","options","extensionRegex","_await$ExponentAV$pre","uri","currentStatus","_args7","arguments","prepareToRecordAsync$","_context7","length","undefined","test","toString","addListener","prepareAudioRecorder","_objectSpread","startAsync","startAsync$","_context8","startAudioRecording","pauseAsync","pauseAsync$","_context9","pauseAudioRecording","stopAndUnloadAsync","stopResult","stopError","stopAndUnloadAsync$","_context10","stopAudioRecording","unloadAudioRecorder","reject","getURI","createNewLoadedSound","initialStatus","onPlaybackStatusUpdate","_args11","createNewLoadedSound$","_context11","console","warn","createNewLoadedSoundAsync","_args12","createNewLoadedSoundAsync$","_context12","createAsync","_callee4","recording","_args13","_callee4$","_context13","keepAudioActiveHint"],"sources":["C:\\Users\\alexd\\Documents\\InstagramClone\\frontend\\node_modules\\expo-av\\src\\Audio\\Recording.ts"],"sourcesContent":["import { EventEmitter, Subscription, Platform } from '@unimodules/core';\nimport { PermissionResponse, PermissionStatus } from 'expo-modules-core';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport { Sound } from './Sound';\n\nexport type RecordingOptions = {\n  isMeteringEnabled?: boolean;\n  keepAudioActiveHint?: boolean;\n  android: {\n    extension: string;\n    outputFormat: number;\n    audioEncoder: number;\n    sampleRate?: number;\n    numberOfChannels?: number;\n    bitRate?: number;\n    maxFileSize?: number;\n  };\n  ios: {\n    extension: string;\n    outputFormat?: string | number;\n    audioQuality: number;\n    sampleRate: number;\n    numberOfChannels: number;\n    bitRate: number;\n    bitRateStrategy?: number;\n    bitDepthHint?: number;\n    linearPCMBitDepth?: number;\n    linearPCMIsBigEndian?: boolean;\n    linearPCMIsFloat?: boolean;\n  };\n};\n\n// TODO: consider changing these to enums\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\n\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\n\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\n\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\n\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\n\n// TODO : maybe make presets for music and speech, or lossy / lossless.\n\nexport const RECORDING_OPTIONS_PRESET_HIGH_QUALITY: RecordingOptions = {\n  isMeteringEnabled: true,\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\nexport const RECORDING_OPTIONS_PRESET_LOW_QUALITY: RecordingOptions = {\n  isMeteringEnabled: true,\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\n// TODO: For consistency with PlaybackStatus, should we include progressUpdateIntervalMillis here as\n// well?\nexport type RecordingStatus = {\n  canRecord: boolean;\n  isRecording: boolean;\n  isDoneRecording: boolean;\n  durationMillis: number;\n  metering?: number;\n};\n\nexport { PermissionResponse, PermissionStatus };\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus?: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch (error) {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n\n  static createAsync = async (\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY,\n    onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null,\n    progressUpdateIntervalMillis: number | null = null\n  ): Promise<{ recording: Recording; status: RecordingStatus }> => {\n    const recording: Recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true,\n    });\n    try {\n      const status = await recording.startAsync();\n      return { recording, status };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  async prepareToRecordAsync(\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult: RecordingStatus | undefined;\n    let stopError: Error | undefined;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n\n  // Read API\n\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  /** @deprecated Use `createNewLoadedSoundAsync()` instead */\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: AVPlaybackStatus }> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: AVPlaybackStatus }> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}