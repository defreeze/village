{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { computeNextBackoffInterval } from '@ide/backoff';\nimport { CodedError, Platform, UnavailabilityError } from '@unimodules/core';\nimport * as Application from 'expo-application';\nimport ServerRegistrationModule from \"../ServerRegistrationModule\";\nvar updateDevicePushTokenUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';\nexport function updateDevicePushTokenAsync(signal, token) {\n  var doUpdateDevicePushTokenAsync, shouldTry, retry, retriesCount, initialBackoff, backoffOptions, nextBackoffInterval;\n  return _regeneratorRuntime.async(function updateDevicePushTokenAsync$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        doUpdateDevicePushTokenAsync = function doUpdateDevicePushTokenAsync(retry) {\n          var _await$Promise$all, _await$Promise$all2, development, deviceId, body, response;\n          return _regeneratorRuntime.async(function doUpdateDevicePushTokenAsync$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _regeneratorRuntime.awrap(Promise.all([shouldUseDevelopmentNotificationService(), getDeviceIdAsync()]));\n              case 2:\n                _await$Promise$all = _context.sent;\n                _await$Promise$all2 = _slicedToArray(_await$Promise$all, 2);\n                development = _await$Promise$all2[0];\n                deviceId = _await$Promise$all2[1];\n                body = {\n                  deviceId: deviceId,\n                  development: development,\n                  deviceToken: token.data,\n                  appId: Application.applicationId,\n                  type: getTypeOfToken(token)\n                };\n                _context.prev = 7;\n                _context.next = 10;\n                return _regeneratorRuntime.awrap(fetch(updateDevicePushTokenUrl, {\n                  method: 'POST',\n                  headers: {\n                    'content-type': 'application/json'\n                  },\n                  body: JSON.stringify(body),\n                  signal: signal\n                }));\n              case 10:\n                response = _context.sent;\n                if (response.ok) {\n                  _context.next = 17;\n                  break;\n                }\n                _context.t0 = console;\n                _context.next = 15;\n                return _regeneratorRuntime.awrap(response.text());\n              case 15:\n                _context.t1 = _context.sent;\n                _context.t0.debug.call(_context.t0, '[expo-notifications] Error encountered while updating the device push token with the server:', _context.t1);\n              case 17:\n                if (!response.ok) {\n                  retry();\n                }\n                _context.next = 26;\n                break;\n              case 20:\n                _context.prev = 20;\n                _context.t2 = _context[\"catch\"](7);\n                if (!(_context.t2.name === 'AbortError')) {\n                  _context.next = 24;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 24:\n                console.warn('[expo-notifications] Error thrown while updating the device push token with the server:', _context.t2);\n                retry();\n              case 26:\n              case \"end\":\n                return _context.stop();\n            }\n          }, null, null, [[7, 20]], Promise);\n        };\n        shouldTry = true;\n        retry = function retry() {\n          shouldTry = true;\n        };\n        retriesCount = 0;\n        initialBackoff = 500;\n        backoffOptions = {\n          maxBackoff: 2 * 60 * 1000\n        };\n        nextBackoffInterval = computeNextBackoffInterval(initialBackoff, retriesCount, backoffOptions);\n      case 7:\n        if (!(shouldTry && !signal.aborted)) {\n          _context2.next = 18;\n          break;\n        }\n        shouldTry = false;\n        _context2.next = 11;\n        return _regeneratorRuntime.awrap(doUpdateDevicePushTokenAsync(retry));\n      case 11:\n        if (!(shouldTry && !signal.aborted)) {\n          _context2.next = 16;\n          break;\n        }\n        nextBackoffInterval = computeNextBackoffInterval(initialBackoff, retriesCount, backoffOptions);\n        retriesCount += 1;\n        _context2.next = 16;\n        return _regeneratorRuntime.awrap(new Promise(function (resolve) {\n          return setTimeout(resolve, nextBackoffInterval);\n        }));\n      case 16:\n        _context2.next = 7;\n        break;\n      case 18:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getDeviceIdAsync() {\n  return _regeneratorRuntime.async(function getDeviceIdAsync$(_context3) {\n    while (1) switch (_context3.prev = _context3.next) {\n      case 0:\n        _context3.prev = 0;\n        if (ServerRegistrationModule.getInstallationIdAsync) {\n          _context3.next = 3;\n          break;\n        }\n        throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n      case 3:\n        _context3.next = 5;\n        return _regeneratorRuntime.awrap(ServerRegistrationModule.getInstallationIdAsync());\n      case 5:\n        return _context3.abrupt(\"return\", _context3.sent);\n      case 8:\n        _context3.prev = 8;\n        _context3.t0 = _context3[\"catch\"](0);\n        throw new CodedError('ERR_NOTIFICATIONS_DEVICE_ID', \"Could not fetch the installation ID of the application: \" + _context3.t0 + \".\");\n      case 11:\n      case \"end\":\n        return _context3.stop();\n    }\n  }, null, null, [[0, 8]], Promise);\n}\nfunction getTypeOfToken(devicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    default:\n      return devicePushToken.type;\n  }\n}\nfunction shouldUseDevelopmentNotificationService() {\n  var notificationServiceEnvironment;\n  return _regeneratorRuntime.async(function shouldUseDevelopmentNotificationService$(_context4) {\n    while (1) switch (_context4.prev = _context4.next) {\n      case 0:\n        if (!(Platform.OS === 'ios')) {\n          _context4.next = 11;\n          break;\n        }\n        _context4.prev = 1;\n        _context4.next = 4;\n        return _regeneratorRuntime.awrap(Application.getIosPushNotificationServiceEnvironmentAsync());\n      case 4:\n        notificationServiceEnvironment = _context4.sent;\n        if (!(notificationServiceEnvironment === 'development')) {\n          _context4.next = 7;\n          break;\n        }\n        return _context4.abrupt(\"return\", true);\n      case 7:\n        _context4.next = 11;\n        break;\n      case 9:\n        _context4.prev = 9;\n        _context4.t0 = _context4[\"catch\"](1);\n      case 11:\n        return _context4.abrupt(\"return\", false);\n      case 12:\n      case \"end\":\n        return _context4.stop();\n    }\n  }, null, null, [[1, 9]], Promise);\n}","map":{"version":3,"names":["computeNextBackoffInterval","CodedError","Platform","UnavailabilityError","Application","ServerRegistrationModule","updateDevicePushTokenUrl","updateDevicePushTokenAsync","signal","token","doUpdateDevicePushTokenAsync","shouldTry","retry","retriesCount","initialBackoff","backoffOptions","nextBackoffInterval","_regeneratorRuntime","async","updateDevicePushTokenAsync$","_context2","prev","next","_await$Promise$all","_await$Promise$all2","development","deviceId","body","response","doUpdateDevicePushTokenAsync$","_context","awrap","Promise","all","shouldUseDevelopmentNotificationService","getDeviceIdAsync","sent","_slicedToArray","deviceToken","data","appId","applicationId","type","getTypeOfToken","fetch","method","headers","JSON","stringify","ok","t0","console","text","t1","debug","call","t2","name","abrupt","warn","stop","maxBackoff","aborted","resolve","setTimeout","getDeviceIdAsync$","_context3","getInstallationIdAsync","devicePushToken","notificationServiceEnvironment","shouldUseDevelopmentNotificationService$","_context4","OS","getIosPushNotificationServiceEnvironmentAsync"],"sources":["C:\\Users\\alexd\\Documents\\InstagramClone\\frontend\\node_modules\\expo-notifications\\src\\utils\\updateDevicePushTokenAsync.ts"],"sourcesContent":["import { computeNextBackoffInterval } from '@ide/backoff';\nimport { CodedError, Platform, UnavailabilityError } from '@unimodules/core';\nimport * as Application from 'expo-application';\n\nimport ServerRegistrationModule from '../ServerRegistrationModule';\nimport { DevicePushToken } from '../Tokens.types';\n\nconst updateDevicePushTokenUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';\n\nexport async function updateDevicePushTokenAsync(signal: AbortSignal, token: DevicePushToken) {\n  const doUpdateDevicePushTokenAsync = async (retry: () => void) => {\n    const [development, deviceId] = await Promise.all([\n      shouldUseDevelopmentNotificationService(),\n      getDeviceIdAsync(),\n    ]);\n    const body = {\n      deviceId,\n      development,\n      deviceToken: token.data,\n      appId: Application.applicationId,\n      type: getTypeOfToken(token),\n    };\n\n    try {\n      const response = await fetch(updateDevicePushTokenUrl, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n        signal,\n      });\n\n      // Help debug erroring servers\n      if (!response.ok) {\n        console.debug(\n          '[expo-notifications] Error encountered while updating the device push token with the server:',\n          await response.text()\n        );\n      }\n\n      // Retry if request failed\n      if (!response.ok) {\n        retry();\n      }\n    } catch (e) {\n      // Error returned if the request is aborted should be an 'AbortError'. In\n      // React Native fetch is polyfilled using `whatwg-fetch` which:\n      // - creates `AbortError`s like this\n      //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L505\n      // - which creates exceptions like\n      //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L490-L494\n      if (e.name === 'AbortError') {\n        // We don't consider AbortError a failure, it's a sign somewhere else the\n        // request is expected to succeed and we don't need this one, so let's\n        // just return.\n        return;\n      }\n\n      console.warn(\n        '[expo-notifications] Error thrown while updating the device push token with the server:',\n        e\n      );\n\n      retry();\n    }\n  };\n\n  let shouldTry = true;\n  const retry = () => {\n    shouldTry = true;\n  };\n\n  let retriesCount = 0;\n  const initialBackoff = 500; // 0.5 s\n  const backoffOptions = {\n    maxBackoff: 2 * 60 * 1000, // 2 minutes\n  };\n  let nextBackoffInterval = computeNextBackoffInterval(\n    initialBackoff,\n    retriesCount,\n    backoffOptions\n  );\n\n  while (shouldTry && !signal.aborted) {\n    // Will be set to true by `retry` if it's called\n    shouldTry = false;\n    await doUpdateDevicePushTokenAsync(retry);\n\n    // Do not wait if we won't retry\n    if (shouldTry && !signal.aborted) {\n      nextBackoffInterval = computeNextBackoffInterval(\n        initialBackoff,\n        retriesCount,\n        backoffOptions\n      );\n      retriesCount += 1;\n      await new Promise(resolve => setTimeout(resolve, nextBackoffInterval));\n    }\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_DEVICE_ID',\n      `Could not fetch the installation ID of the application: ${e}.`\n    );\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment = await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch (e) {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n"],"mappings":";;AAAA,SAASA,0BAA0B,QAAQ,cAAc;AACzD,SAASC,UAAU,EAAEC,QAAQ,EAAEC,mBAAmB,QAAQ,kBAAkB;AAC5E,OAAO,KAAKC,WAAW,MAAM,kBAAkB;AAE/C,OAAOC,wBAAwB;AAG/B,IAAMC,wBAAwB,GAAG,mDAAmD;AAEpF,OAAO,SAAeC,0BAA0BA,CAACC,MAAmB,EAAEC,KAAsB;EAAA,IAAAC,4BAAA,EAAAC,SAAA,EAAAC,KAAA,EAAAC,YAAA,EAAAC,cAAA,EAAAC,cAAA,EAAAC,mBAAA;EAAA,OAAAC,mBAAA,CAAAC,KAAA,UAAAC,4BAAAC,SAAA;IAAA,kBAAAA,SAAA,CAAAC,IAAA,GAAAD,SAAA,CAAAE,IAAA;MAAA;QACpFZ,4BAA4B,GAAG,SAA/BA,4BAA4BA,CAAUE,KAAiB;UAAA,IAAAW,kBAAA,EAAAC,mBAAA,EAAAC,WAAA,EAAAC,QAAA,EAAAC,IAAA,EAAAC,QAAA;UAAA,OAAAX,mBAAA,CAAAC,KAAA,UAAAW,8BAAAC,QAAA;YAAA,kBAAAA,QAAA,CAAAT,IAAA,GAAAS,QAAA,CAAAR,IAAA;cAAA;gBAAAQ,QAAA,CAAAR,IAAA;gBAAA,OAAAL,mBAAA,CAAAc,KAAA,CACrBC,OAAO,CAACC,GAAG,CAAC,CAChDC,uCAAuC,EAAE,EACzCC,gBAAgB,EAAE,CACnB,CAAC;cAAA;gBAAAZ,kBAAA,GAAAO,QAAA,CAAAM,IAAA;gBAAAZ,mBAAA,GAAAa,cAAA,CAAAd,kBAAA;gBAHKE,WAAW,GAAAD,mBAAA;gBAAEE,QAAQ,GAAAF,mBAAA;gBAItBG,IAAI,GAAG;kBACXD,QAAQ,EAARA,QAAQ;kBACRD,WAAW,EAAXA,WAAW;kBACXa,WAAW,EAAE7B,KAAK,CAAC8B,IAAI;kBACvBC,KAAK,EAAEpC,WAAW,CAACqC,aAAa;kBAChCC,IAAI,EAAEC,cAAc,CAAClC,KAAK;iBAC3B;gBAAAqB,QAAA,CAAAT,IAAA;gBAAAS,QAAA,CAAAR,IAAA;gBAAA,OAAAL,mBAAA,CAAAc,KAAA,CAGwBa,KAAK,CAACtC,wBAAwB,EAAE;kBACrDuC,MAAM,EAAE,MAAM;kBACdC,OAAO,EAAE;oBACP,cAAc,EAAE;mBACjB;kBACDnB,IAAI,EAAEoB,IAAI,CAACC,SAAS,CAACrB,IAAI,CAAC;kBAC1BnB,MAAM,EAANA;iBACD,CAAC;cAAA;gBAPIoB,QAAQ,GAAAE,QAAA,CAAAM,IAAA;gBAAA,IAUTR,QAAQ,CAACqB,EAAE;kBAAAnB,QAAA,CAAAR,IAAA;kBAAA;gBAAA;gBAAAQ,QAAA,CAAAoB,EAAA,GACdC,OAAO;gBAAArB,QAAA,CAAAR,IAAA;gBAAA,OAAAL,mBAAA,CAAAc,KAAA,CAECH,QAAQ,CAACwB,IAAI,EAAE;cAAA;gBAAAtB,QAAA,CAAAuB,EAAA,GAAAvB,QAAA,CAAAM,IAAA;gBAAAN,QAAA,CAAAoB,EAAA,CAFfI,KAAK,CAAAC,IAAA,CAAAzB,QAAA,CAAAoB,EAAA,EACX,8FAA8F,EAAApB,QAAA,CAAAuB,EAAA;cAAA;gBAMlG,IAAI,CAACzB,QAAQ,CAACqB,EAAE,EAAE;kBAChBrC,KAAK,EAAE;;gBACRkB,QAAA,CAAAR,IAAA;gBAAA;cAAA;gBAAAQ,QAAA,CAAAT,IAAA;gBAAAS,QAAA,CAAA0B,EAAA,GAAA1B,QAAA;gBAAA,MAQGA,QAAA,CAAA0B,EAAA,CAAEC,IAAI,KAAK,YAAY;kBAAA3B,QAAA,CAAAR,IAAA;kBAAA;gBAAA;gBAAA,OAAAQ,QAAA,CAAA4B,MAAA;cAAA;gBAO3BP,OAAO,CAACQ,IAAI,CACV,yFAAyF,EAAA7B,QAAA,CAAA0B,EACxF,CACF;gBAED5C,KAAK,EAAE;cAAC;cAAA;gBAAA,OAAAkB,QAAA,CAAA8B,IAAA;YAAA;UAAA,0BAAA5B,OAAA;QAAA,CAEX;QAEGrB,SAAS,GAAG,IAAI;QACdC,KAAK,GAAG,SAARA,KAAKA,CAAA,EAAQ;UACjBD,SAAS,GAAG,IAAI;QAClB,CAAC;QAEGE,YAAY,GAAG,CAAC;QACdC,cAAc,GAAG,GAAG;QACpBC,cAAc,GAAG;UACrB8C,UAAU,EAAE,CAAC,GAAG,EAAE,GAAG;SACtB;QACG7C,mBAAmB,GAAGhB,0BAA0B,CAClDc,cAAc,EACdD,YAAY,EACZE,cAAc,CACf;MAAA;QAAA,MAEMJ,SAAS,IAAI,CAACH,MAAM,CAACsD,OAAO;UAAA1C,SAAA,CAAAE,IAAA;UAAA;QAAA;QAEjCX,SAAS,GAAG,KAAK;QAACS,SAAA,CAAAE,IAAA;QAAA,OAAAL,mBAAA,CAAAc,KAAA,CACZrB,4BAA4B,CAACE,KAAK,CAAC;MAAA;QAAA,MAGrCD,SAAS,IAAI,CAACH,MAAM,CAACsD,OAAO;UAAA1C,SAAA,CAAAE,IAAA;UAAA;QAAA;QAC9BN,mBAAmB,GAAGhB,0BAA0B,CAC9Cc,cAAc,EACdD,YAAY,EACZE,cAAc,CACf;QACDF,YAAY,IAAI,CAAC;QAACO,SAAA,CAAAE,IAAA;QAAA,OAAAL,mBAAA,CAAAc,KAAA,CACZ,IAAIC,OAAO,CAAC,UAAA+B,OAAO;UAAA,OAAIC,UAAU,CAACD,OAAO,EAAE/C,mBAAmB,CAAC;QAAA,EAAC;MAAA;QAAAI,SAAA,CAAAE,IAAA;QAAA;MAAA;MAAA;QAAA,OAAAF,SAAA,CAAAwC,IAAA;IAAA;EAAA,qBAAA5B,OAAA;AAAA;AAM5E,SAAeG,gBAAgBA,CAAA;EAAA,OAAAlB,mBAAA,CAAAC,KAAA,UAAA+C,kBAAAC,SAAA;IAAA,kBAAAA,SAAA,CAAA7C,IAAA,GAAA6C,SAAA,CAAA5C,IAAA;MAAA;QAAA4C,SAAA,CAAA7C,IAAA;QAAA,IAEtBhB,wBAAwB,CAAC8D,sBAAsB;UAAAD,SAAA,CAAA5C,IAAA;UAAA;QAAA;QAAA,MAC5C,IAAInB,mBAAmB,CAAC,8BAA8B,EAAE,wBAAwB,CAAC;MAAA;QAAA+D,SAAA,CAAA5C,IAAA;QAAA,OAAAL,mBAAA,CAAAc,KAAA,CAG5E1B,wBAAwB,CAAC8D,sBAAsB,EAAE;MAAA;QAAA,OAAAD,SAAA,CAAAR,MAAA,WAAAQ,SAAA,CAAA9B,IAAA;MAAA;QAAA8B,SAAA,CAAA7C,IAAA;QAAA6C,SAAA,CAAAhB,EAAA,GAAAgB,SAAA;QAAA,MAExD,IAAIjE,UAAU,CAClB,6BAA6B,+DAAAiE,SAAA,CAAAhB,EAAA,MACkC,CAChE;MAAA;MAAA;QAAA,OAAAgB,SAAA,CAAAN,IAAA;IAAA;EAAA,yBAAA5B,OAAA;AAAA;AAKL,SAASW,cAAcA,CAACyB,eAAgC;EACtD,QAAQA,eAAe,CAAC1B,IAAI;IAC1B,KAAK,KAAK;MACR,OAAO,MAAM;IACf,KAAK,SAAS;MACZ,OAAO,KAAK;IAEd;MACE,OAAO0B,eAAe,CAAC1B,IAAI;;AAEjC;AAGA,SAAeR,uCAAuCA,CAAA;EAAA,IAAAmC,8BAAA;EAAA,OAAApD,mBAAA,CAAAC,KAAA,UAAAoD,yCAAAC,SAAA;IAAA,kBAAAA,SAAA,CAAAlD,IAAA,GAAAkD,SAAA,CAAAjD,IAAA;MAAA;QAAA,MAChDpB,QAAQ,CAACsE,EAAE,KAAK,KAAK;UAAAD,SAAA,CAAAjD,IAAA;UAAA;QAAA;QAAAiD,SAAA,CAAAlD,IAAA;QAAAkD,SAAA,CAAAjD,IAAA;QAAA,OAAAL,mBAAA,CAAAc,KAAA,CAEwB3B,WAAW,CAACqE,6CAA6C,EAAE;MAAA;QAAlGJ,8BAA8B,GAAAE,SAAA,CAAAnC,IAAA;QAAA,MAChCiC,8BAA8B,KAAK,aAAa;UAAAE,SAAA,CAAAjD,IAAA;UAAA;QAAA;QAAA,OAAAiD,SAAA,CAAAb,MAAA,WAC3C,IAAI;MAAA;QAAAa,SAAA,CAAAjD,IAAA;QAAA;MAAA;QAAAiD,SAAA,CAAAlD,IAAA;QAAAkD,SAAA,CAAArB,EAAA,GAAAqB,SAAA;MAAA;QAAA,OAAAA,SAAA,CAAAb,MAAA,WAOV,KAAK;MAAA;MAAA;QAAA,OAAAa,SAAA,CAAAX,IAAA;IAAA;EAAA,yBAAA5B,OAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}