{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport 'abort-controller/polyfill';\nimport { UnavailabilityError } from '@unimodules/core';\nimport ServerRegistrationModule from \"./ServerRegistrationModule\";\nimport { addPushTokenListener } from \"./TokenEmitter\";\nimport getDevicePushTokenAsync from \"./getDevicePushTokenAsync\";\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from \"./utils/updateDevicePushTokenAsync\";\nvar lastAbortController = null;\nfunction updatePushTokenAsync(token) {\n  var _lastAbortController;\n  return _regeneratorRuntime.async(function updatePushTokenAsync$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        (_lastAbortController = lastAbortController) == null ? void 0 : _lastAbortController.abort();\n        lastAbortController = new AbortController();\n        _context.next = 4;\n        return _regeneratorRuntime.awrap(updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token));\n      case 4:\n        return _context.abrupt(\"return\", _context.sent);\n      case 5:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, null, Promise);\n}\nexport function setAutoServerRegistrationEnabledAsync(enabled) {\n  var _lastAbortController2;\n  return _regeneratorRuntime.async(function setAutoServerRegistrationEnabledAsync$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        (_lastAbortController2 = lastAbortController) == null ? void 0 : _lastAbortController2.abort();\n        if (ServerRegistrationModule.setRegistrationInfoAsync) {\n          _context2.next = 3;\n          break;\n        }\n        throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n      case 3:\n        _context2.next = 5;\n        return _regeneratorRuntime.awrap(ServerRegistrationModule.setRegistrationInfoAsync(enabled ? JSON.stringify({\n          isEnabled: enabled\n        }) : null));\n      case 5:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, null, null, null, Promise);\n}\nexport function __handlePersistedRegistrationInfoAsync(registrationInfo) {\n  var _registration;\n  var registration, latestDevicePushToken;\n  return _regeneratorRuntime.async(function __handlePersistedRegistrationInfoAsync$(_context3) {\n    while (1) switch (_context3.prev = _context3.next) {\n      case 0:\n        if (registrationInfo) {\n          _context3.next = 2;\n          break;\n        }\n        return _context3.abrupt(\"return\");\n      case 2:\n        registration = null;\n        try {\n          registration = JSON.parse(registrationInfo);\n        } catch (e) {\n          console.warn('[expo-notifications] Error encountered while fetching registration information for auto token updates.', e);\n        }\n        if ((_registration = registration) != null && _registration.isEnabled) {\n          _context3.next = 6;\n          break;\n        }\n        return _context3.abrupt(\"return\");\n      case 6:\n        _context3.prev = 6;\n        _context3.next = 9;\n        return _regeneratorRuntime.awrap(getDevicePushTokenAsync());\n      case 9:\n        latestDevicePushToken = _context3.sent;\n        _context3.next = 12;\n        return _regeneratorRuntime.awrap(updatePushTokenAsync(latestDevicePushToken));\n      case 12:\n        _context3.next = 17;\n        break;\n      case 14:\n        _context3.prev = 14;\n        _context3.t0 = _context3[\"catch\"](6);\n        console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.', _context3.t0);\n      case 17:\n      case \"end\":\n        return _context3.stop();\n    }\n  }, null, null, [[6, 14]], Promise);\n}\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  addPushTokenListener(function _callee(token) {\n    var registrationInfo, registration;\n    return _regeneratorRuntime.async(function _callee$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.prev = 0;\n          _context4.next = 3;\n          return _regeneratorRuntime.awrap(ServerRegistrationModule.getRegistrationInfoAsync());\n        case 3:\n          registrationInfo = _context4.sent;\n          if (registrationInfo) {\n            _context4.next = 6;\n            break;\n          }\n          return _context4.abrupt(\"return\");\n        case 6:\n          registration = JSON.parse(registrationInfo);\n          if (!(registration != null && registration.isEnabled)) {\n            _context4.next = 10;\n            break;\n          }\n          _context4.next = 10;\n          return _regeneratorRuntime.awrap(updatePushTokenAsync(token));\n        case 10:\n          _context4.next = 15;\n          break;\n        case 12:\n          _context4.prev = 12;\n          _context4.t0 = _context4[\"catch\"](0);\n          console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.', _context4.t0);\n        case 15:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, null, null, [[0, 12]], Promise);\n  });\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\"[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.\", new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync'));\n}","map":{"version":3,"names":["UnavailabilityError","ServerRegistrationModule","addPushTokenListener","getDevicePushTokenAsync","updateDevicePushTokenAsync","updateDevicePushTokenAsyncWithSignal","lastAbortController","updatePushTokenAsync","token","_lastAbortController","_regeneratorRuntime","async","updatePushTokenAsync$","_context","prev","next","abort","AbortController","awrap","signal","abrupt","sent","stop","Promise","setAutoServerRegistrationEnabledAsync","enabled","_lastAbortController2","setAutoServerRegistrationEnabledAsync$","_context2","setRegistrationInfoAsync","JSON","stringify","isEnabled","__handlePersistedRegistrationInfoAsync","registrationInfo","_registration","registration","latestDevicePushToken","__handlePersistedRegistrationInfoAsync$","_context3","parse","e","console","warn","t0","getRegistrationInfoAsync","_callee","_callee$","_context4","then"],"sources":["C:\\Users\\alexd\\Documents\\InstagramClone\\frontend\\node_modules\\expo-notifications\\src\\DevicePushTokenAutoRegistration.fx.ts"],"sourcesContent":["import 'abort-controller/polyfill';\nimport { UnavailabilityError } from '@unimodules/core';\n\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from './utils/updateDevicePushTokenAsync';\n\nlet lastAbortController: AbortController | null = null;\nasync function updatePushTokenAsync(token: DevicePushToken) {\n  // Abort current update process\n  lastAbortController?.abort();\n  lastAbortController = new AbortController();\n  return await updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n}\n\n/**\n * Encapsulates device server registration data\n */\nexport type DevicePushTokenRegistration = {\n  isEnabled: boolean;\n};\n\n/**\n * Sets the registration information so that the device push token gets pushed\n * to the given registration endpoint\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function setAutoServerRegistrationEnabledAsync(enabled: boolean) {\n  // We are overwriting registration, so we shouldn't let\n  // any pending request complete.\n  lastAbortController?.abort();\n\n  if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n    throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n  }\n\n  await ServerRegistrationModule.setRegistrationInfoAsync(\n    enabled ? JSON.stringify({ isEnabled: enabled }) : null\n  );\n}\n\n/**\n * This function is exported only for testing purposes.\n */\nexport async function __handlePersistedRegistrationInfoAsync(\n  registrationInfo: string | null | undefined\n) {\n  if (!registrationInfo) {\n    // No registration info, nothing to do\n    return;\n  }\n\n  let registration: DevicePushTokenRegistration | null = null;\n  try {\n    registration = JSON.parse(registrationInfo);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching registration information for auto token updates.',\n      e\n    );\n  }\n\n  if (!registration?.isEnabled) {\n    // Registration is invalid or not enabled, nothing more to do\n    return;\n  }\n\n  try {\n    // Since the registration is enabled, fetching a \"new\" device token\n    // shouldn't be a problem.\n    const latestDevicePushToken = await getDevicePushTokenAsync();\n    await updatePushTokenAsync(latestDevicePushToken);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n      e\n    );\n  }\n}\n\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  // A global scope (to get all the updates) device push token\n  // subscription, never cleared.\n  addPushTokenListener(async token => {\n    try {\n      // Before updating the push token on server we always check if we should\n      // Since modules can't change their method availability while running, we\n      // can assert it's defined.\n      const registrationInfo = await ServerRegistrationModule.getRegistrationInfoAsync!();\n\n      if (!registrationInfo) {\n        // Registration is not enabled\n        return;\n      }\n\n      const registration: DevicePushTokenRegistration | null = JSON.parse(registrationInfo);\n      if (registration?.isEnabled) {\n        // Dispatch an abortable task to update\n        // registration with new token.\n        await updatePushTokenAsync(token);\n      }\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n        e\n      );\n    }\n  });\n\n  // Verify if persisted registration\n  // has successfully uploaded last known\n  // device push token. If not, retry.\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\n    `[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.`,\n    new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync')\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}